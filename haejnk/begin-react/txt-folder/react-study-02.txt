2021-08-17

04. JSX 의 기본 규칙 알아보기

- Babel ?
  >> 자바스크립트의 문법을 확장해주는 도구
  >> 아직 지원하지 않는 최신 문법을 정식 자바스크립트로 변환해준다
  
  >> JSX : 리액트에서 생김새를 정의할 때, 사용하는 문법이다.
  >> HTML 같이 생겼지만 JavaScript 이다
    >> return <div>안녕하세요</div>  

- 리액트 컴포넌트 개발시 지켜야 할 문법 규칙
  - 꼭 닫혀야 하는 태그
    >> 태그는 꼭 닫혀 있어야 한다. 그렇지 않을 시 오류가 발생한다
    >> 태그와 태그 사이에 내용이 들어가지 않을 때, Self Closing 태그 라는 것을 사용해야 한다. 열리고 바로 닫히는 태그를 의미한다.
  - 꼭 감싸져야 하는 태그
    >> 두 개 이상의 태그는 무조건 하나의 태그로 감싸져 있어야 한다. 그렇지 않을 시 오류 발생.
    >> 리액트의 Fragment 사용 => '<></>'
  - JSX 안에 자바스크립트 값 사용하기
    >> JSX 내부에 자바스크립트 변수를 보여줘야 할 때에는 {} 로 감싸서 보여준다.
  - style 과 className
    >> 인라인 스타일은 객체 형태로 작성을 해야 한다.
    >> '-' 로 구분되어 있는 이름들 (ex: background-color) 은 camelCase 형태 (ex: backgroundColor) 로 네이밍 해줘야 한다.
    >> CSS class 를 설정할 때에는 'class=' 가 아닌 'className=' 으로 설정 해줘야 한다.
  - 주석
    >> {/* multiline 주석 형태 */}
    >> // 열리는 태그 내부에서는 이런 형태로 주석 작성 가능

05. props 를 통해 컴포넌트에게 값 전달하기

- props?
  >> properties 의 줄임말.
  >> 어떠한 값을 컴포넌트에게 전달해줘야 할 때 사용.
  
- props 의 기본 사용법
  >> App 컴포넌트에서 Hello 컴포넌트를 사용 할 때 name 이라는 값을 전달하는 코드
    >> <Hello name="react" />
  >> Hello 컴포넌트에서 name 값을 사용하는 코드
    >> function Hello(props) {
        return <div>안녕하세요 {props.name}</div>
      }
    >> 컴포넌트에게 전달되는 props 는 파라미터를 통하여 조회할 수 있다.
      >> 파라미터 : 매개변수, 인자. 함수를 정의할 때 값을 전달받는 변수를 의미.
    >> props 는 객체 형태로 전달되고, 내부 값을 조회하고 싶다면 props.name 으로 조회할 수 있다.
- 여러개의 props, 비구조화 할당
  >> color 값을 설정한 후 컴포넌트에서 값을 조회하여 style 을 변경.
    >> function Hello(props) {
        return <div style={{ color: props.color }}>안녕하세요 {props.name}</div>
      }
    >> 함수의 파라미터에서 비구조화 할당 문법을 사용하면 조금 더 코드를 간결하게 작성 할 수 있다.
      >> function Hello({ color, name }) {
          return <div style={{ color }}>안녕하세요 {name}</div>
        }
- defaultProps 로 기본값 설정
  >> 컴포넌트에 props 를 지정하지 않았을 때 기본적으로 사용할 값을 설정하고 싶다면
  >> 컴포넌트에 defaultProps 라는 값을 설정한다
    >> Hello.defaultProps = {
        name: '이름없음'
       }
- props.children
  >> 컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 때 => props.children 조회.
    >> function Wrapper({ children }) {
        ...
        return (
          <div style={style}>
            {children}
          </div>
        )
        ...

06. 조건부 렌더링

- 조건부 렌더링 ?
  >> 특정 조건에 따라 다른 결과물을 렌더링 하는 것을 의미한다.
    >> 어떤 값이 true 냐 false 냐로 값을 구분지을 때, 가장 기본적인 방법은 삼항 연산자를 사용하는 것이다.
      >> 삼항 연산자를 사용한 조건부 렌더링은 주로 특정 조건에 따라 보여줘야 하는 내용이 다를 때 사용한다.
    >> JSX 에서 null, false, undefined 를 렌더링하게 되면 아무것도 나타나지 않는다
    >> 단순하게 조건을 true 또는 false 로 구분하는 경우 && 연산자를 사용해서 처리하는 것이 더 간편하다

- props 값 설정을 생략하면 ={true}
  >> 컴포넌트의 props 값을 설정하게 될 때 이름만 작성하고 값 설정을 생략하면 true 로 설정한 것으로 간주한다
  >> (ex) <Hello name="react" color="red" isSpecial />

07. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기

- 컴포넌트 내용이 사용자 인터랙션에 따라 바뀌어야 할 때 구현.
  >> 리액트 16.8 버전에서 Hooks 라는 기능이 도입되면서 함수형 컴포넌트에서 상태 관리가 가능해졌다.
  >> useState 함수 사용.

- 이벤트 설정
  >> 화살표 함수 사용하여 구현.
  >> 엘리먼트에 이벤트를 설정해줄 때, on이벤트이름={실행하고싶은함수} 형태로 설정.
    >> 함수형태를 넣어야하지, 실행하면 안된다. 
    >> onClick{onIncrease()} <= X
  
- 동적인 값 끼얹기, useState
  >> 상태(state) : 컴포넌트에서 동적인 값을 의미한다.
  >> import React, { useState } from 'react';
  >> 리액트 패키지에서 useState 라는 함수를 불러와주는 코드
  >> const [number, setNumber] = useState(0);
    >> 상태의 기본값을 파라미터로 넣어서 호출.
    >> 이 함수를 호출해 주면 배열이 반환된다.
    >> 첫번째 원소는 현재 상태, 두번째 원소는 Setter 함수.
      >> Setter 함수는 파라미터로 전달 받은 값을 최신 상태로 설정해 준다.

- 함수형 업데이트
  >> 기존 값을 어떻게 업데이트 할 지에 대한 함수를 등록하는 방식으로도 값을 업데이트 할 수 있다.
  >> 함수형 업데이트는 주로 나중에 컴포넌트를 최적화를 하게 될 때 사용하게 된다.

08. input 상태 관리하기

- 사용자가 입력 할 수 있는 input 태그의 상태를 관리하는 방법
  >> useState 함수, onChange 이벤트 사용.
  >> 이벤트 객체 e 를 파라미터로 받아올 수 있다.
  >> 이 객체의 e.target 은 이벤트가 발생한 DOM (input DOM) 을 가르키게 된다.
  >> e.target.value 를 조회하면 현재 input 에 입력한 값이 무엇인지 알 수 있다.

09. 여러개의 input 상태 관리하기

- input 이 여러개일 때 관리하는 방법
  >> input 에 name 을 설정하고 이벤트가 발생했을 때 이 값을 참조
  >> useState 에서 객체 형태의 상태를 관리한다.
  >> input[name] = value; <= X
  >> 리액트 상태에서 객체를 수정해야 할 때에는 새로운 객체를 만들어서 새로운 객체에 변화를 주고,
  이를 상태로 사용해줘야 한다.
  >> setInputs({
      ...inputs,
      [name]: value
    });
  >> spread 문법 사용.
  >> 이러한 작업을, "불변성을 지킨다" 라고 부른다.
  >> 리액트에서는 불변성을 지켜주어야만 컴포넌트 업데이트 성능 최적화를 제대로 할 수 있다.
  >> [중요] 리액트에서 객체를 업데이트하게 될 때에는 기존 객체를 직접 수정하면 안 되고, 새로운 객체를 만들어서,
  새 객체에 변화를 주어야 한다.

10. useRef 로 특정 DOM 선택하기

- 
  >> 리액트를 사용하는 프로젝트에서 가끔 DOM을 직접 선택해야 하는 상황이 발생 할 수 있다.
  >> 그럴 때 리액트에서는 ref 라는 것을 사용한다.
  >> 함수형 컴포넌트에서 ref 를 사용할 때에는 useRef 라는 Hook 함수를 사용한다.
  >> (클래스형 컴포넌트에서는 콜백함수를 사용하거나, React.createRef 라는 함수를 사용한다.)
  >> useRef() 를 사용하여 Ref 객체를 만들고, 선택하고 싶은 DOM 에 ref 값으로 이 객체를 설정해준다.
  >> 그러면 Ref 객체의 .current 값은 우리가 원하는 DOM을 가르키게 된다.

11. 배열 렌더링하기

- 기본적인 방법
  >> 비효율적이지만, 그대로 코드 작성.
  >> 동적인 배열을 렌더링하지 못한다.

- 동적인 배열을 렌더링
  >> 자바스크립트 배열의 내장 함수 map()을 사용한다.
    >> map() : 배열안에 있는 각 원소를 변환하여 새로운 배열을 만든다
  >> 리액트에서 배열을 렌더링 할 때에는 key 라는 props 를 설정해야 한다.
  >> ...
      return (
      <div>
        {user.map(user => (
          <User user={user} key={user.id} />
        ))}
      </div>
    );
    >> (그렇지 않으면 Warning 에러가 뜬다)
  >> key 값은 각 원소들마다 가지고 있는 고유값으로 설정을 해야 한다.
  >> 만약 배열 안의 원소가 가지고 있는 고유한 값이 없을 경우, 
    map() 함수를 사용할 때 설정하는 콜백함수의 두번째 파라미터 index 를 key 로 사용한다.
  >> <di>
      {user.map((user, index) => (
        <User user={user} key={index} />
      ))}
    </div>
  >> (경고 메시지가 뜨는 이유 : 각 고유 원소에 key 가 있어야만 배열이 업데이트 될 때 효율적으로 렌더링 될 수 있기 때문.)

- key 의 존재유무에 따른 업데이트 방식
  >> key 가 없는 경우, 
    >> 어떤 배열의 중간 지점에 새로운 값을 넣거나 배열의 앞 지점에 값을 제거할 경우, 
       리렌더링을 하게 될 때 기존 값들이 한 칸씩 다른 기존값들을 변경시키는 작업이 이루어진다.
  >> key 가 있는 경우,
    >> 배열이 업데이트 될 때 수정되지 않는 기존의 값은 그대로 두고 원하는 곳에 내용을 넣거나 뺀다
  >> 이러한 이유로 배열을 렌더링할 때에는 고유한 key 값이 있는 것이 중요하다.
  >> 만약 배열 안에 중복되는 key 가 있을 때에는 렌더링시에 오류 메시지가 콘솔에 나타나게 되며, 업데이트가 제대로 이루어지지 않는다.

12. useRef 로 컴포넌트 안의 변수 만들기

- useRef Hook 의 용도
  >> 1. DOM 선택
  >> 2. 컴포넌트 안에서 조회 및 수정 할 수 있는 변수 관리
  
  >> useRef 로 관리하고 있는 변수는 값이 바뀐다고 해서 컴포넌트가 리렌더링 되지 않는다.
  >> 설정 후 바로 조회 할 수 있다.
  >> 관리 가능 값
    - setTimeout, setInterval 을 통해서 만들어진 id
    - 외부 라이브러리를 사용하여 생성된 인스턴스
    - scroll 위치

  >> useRef 를 사용하여 변수 관리
    >> 용도 : 배열에 새 항목 추가 시, 새 항목에서 사용할 고유 id 관리 

  >> 변수 관리 전 작업
    >> 다른 컴포넌트에서 배열을 선언하고 본 컴포넌트로 props로 전달 사용.
    
  >> useRef() 를 사용할 때 파라미터를 넣어주면 이 값이 .current 값의 기본값이 된다.
  >> 수정할 때, 조회할 때 .current 값을 사용하면 된다.

13. 배열에 항목 추가하기

- 배열에 새로운 항목 추가하는 방법
  >> 배열에 변화를 줄 때에는 객체와 마찬가지로 불변성을 지켜야 한다.
  >> 불변성을 지키면서 배열에 새 항목을 추가하는 방법
    - spread 연산자 사용
    - concat 함수 사용
  >> 상태 관리는 부모 컴포넌트에서 하게 하고, 이벤트로 등록할 함수들을 자식 컴포넌트의 props 로 넘겨받아 사용하는 구조가 있다.

14. 배열에 항목 제거하기

- 
  >> filter 함수 사용 : 배열에서 특정 조건을 만족하는 원소들만 추출하여 새로운 배열을 만들어 준다
  >> onRemove() : id 가 XXX 인 객체를 삭제해라 라는 역할을 한다.

15. 배열 항목 수정하기

- 
  >> 배열의 불변성을 유지하면서 배열을 업데이트 할 때 : map() 함수 사용
  >> on/off 설정을 할 때 : onToggle 함수 사용

16. useEffect 를 사용하여 마운트/ 언마운트/ 업데이트시 할 작업 설정하기

- useEffect 라는 Hook 사용 하여 특정 작업을 처리하는 방법
  - 컴포넌트가 마운트 됬을 때 (처음 나타났을 때)
  - 언마운트 됬을 때 (사라질 때)
  - 업데이트 될 때 (특정 props 가 바뀔 때)
  
- 마운트 / 언마운트
  >> useEffect 사용할 시
    >> 첫번째 파라미터 : 함수
    >> 두번째 파라미터 : 의존값이 들어있는 배열(deps)
    >> 만약 deps 배열을 비우게 된다면 컴포넌트가 처음 나타날때에만 useEffect 에 등록한 함수가 호출된다.
  >> 함수를 반환할 수 있다. <<< cleanup 함수라고 불린다
    >> useEffect 에 대한 뒷정리를 해준다고 이해하면 된다.
    >> deps 가 비어있는 경우, 컴포넌트가 사라질 때 cleanup 함수 호출됨
  >> 마운트 시 하는 작업들
    - props 로 받은 값을 컴포넌트의 로컬 상태로 설정
    - 외부 API 요청 (REST API 등)
    - 라이브러리 사용 (D3, Video.js 등...)
    - setInterval 을 통한 반복작업 혹은 setTimeout 을 통한 작업 예약
  >> 언마운트 시에 하는 작업들
    - setInterval, setTimeout 을 사용하여 등록한 작업들 clear 하기 (clearInterval, clearTimeout)
    - 라이브러리 인스턴스 제거
  
- deps 에 특정 값 넣기
  >> deps 에 특정 값을 넣게 된다면 
    - 컴포넌트가 처음 마운트 될 때
    - 지정한 값이 바뀔 때           => 호출이 된다.
  >> deps 안에 특정 값이 있다면 
    - 언마운트시
    - 값이 바뀌기 직전 => 호출이 된다.
  >> useEffect 안에서 사용하는 상태나, props 가 있다면, useEffect 의 deps 에 넣어주어야 한다. <= 규칙이다.
  >> 만약 useEffect 안에서 사용하는 상태나 props 를 deps 에 넣지 않게 된다면 useEffect 에 등록한 함수가 실행될 때
    >> 최신 props/상태를 가르키지 않게 된다.
    
- deps 파라미터를 생략하기
  >> deps 파라미터를 생략하면 컴포넌트가 리렌더링 될 때마다 호출된다.

- 참고
  >> 리액트 컴포넌트는 기본적으로 부모컨포넌트가 리렌더링되면 자식 컴포넌트 또한 리렌더링 된다. (바뀐 내용이 없더라도)
  >> 실제 DOM 에는 바뀐 내용이 있는 컴포넌트만 변화가 반영된다.
  >> Virtual DOM 에는 모든 걸 다 렌더링하고 있다.

17. useMemo 를 사용하여 연산한 값 재사용하기

- useMemo
  >> 성능 최적화를 위해 사용.
  >> Memo : memorized 를 의미.
    >> 이전에 계산 한 값을 재사용한다는 의미이다.
  >> 첫번째 파라미터 : 어떻게 연산할지 정의하는 함수
  >> 두번째 파라미터 : deps 배열 <= 배열 안에 넣은 내용이 바뀌면, 우리가 등록한 함수를 호출해서 값을 연산해주고
    >> 만약 내용이 바뀌지 않았다면 이전에 연산한 값을 재사용하게 된다.

18. useCallback 을 사용하여 함수 재사용하기

- useCallback
  >> useMemo 와 비슷한 Hook 이다 => useMemo 기반으로 만들어 졌다.
  >> useMemo : 특정 결과값을 재사용할 때 사용
  >> useCallback : 특정 함수를 새로 만들지 않고 재사용할 때 사용
  >> 첫번쨰 인수 : 함수
  >> 두번쨰 인수 : 배열 (props 에서 사용되는)